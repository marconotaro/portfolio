[
  {
    "objectID": "r2_clustering.html",
    "href": "r2_clustering.html",
    "title": "Identification of breast cancer subtypes",
    "section": "",
    "text": "The goal of this report is to identify breast cancer subtypes by using a graph-based approach. To this end, I built a K-nearest neighbor (KNN) graph, where each node is a patient connected to its nearest neighbors, in the high-dimensional space (i.e. I used the top 25 principal components and the top 3000 variable genes). Edges between patients are weighted based on the Jaccard similarity, the higher the weight the larger is their overlap in their local neighborhoods. I then applied the Louvain algorithm to identify patient communities, where patients in the same group are more strongly connected to each others compared to those in different groups (on the basis of gene expression profiles). Finally, I visualized the cluster distribution with t-SNE and UMAP and I labeled patients on the basis of status of 5 biomarkers (estrogen receptor (ER), progesterone receptor (PgR), human epidermal growth factor receptor 2 (HER2), Ki67, and Nottingham histologic grade (NHG)) to see if there are associations between patients communities and biomarker status."
  },
  {
    "objectID": "r2_clustering.html#aims",
    "href": "r2_clustering.html#aims",
    "title": "Identification of breast cancer subtypes",
    "section": "",
    "text": "The goal of this report is to identify breast cancer subtypes by using a graph-based approach. To this end, I built a K-nearest neighbor (KNN) graph, where each node is a patient connected to its nearest neighbors, in the high-dimensional space (i.e. I used the top 25 principal components and the top 3000 variable genes). Edges between patients are weighted based on the Jaccard similarity, the higher the weight the larger is their overlap in their local neighborhoods. I then applied the Louvain algorithm to identify patient communities, where patients in the same group are more strongly connected to each others compared to those in different groups (on the basis of gene expression profiles). Finally, I visualized the cluster distribution with t-SNE and UMAP and I labeled patients on the basis of status of 5 biomarkers (estrogen receptor (ER), progesterone receptor (PgR), human epidermal growth factor receptor 2 (HER2), Ki67, and Nottingham histologic grade (NHG)) to see if there are associations between patients communities and biomarker status."
  },
  {
    "objectID": "r2_clustering.html#methods",
    "href": "r2_clustering.html#methods",
    "title": "Identification of breast cancer subtypes",
    "section": "Methods",
    "text": "Methods\nDue to the presence of missing values (NA) in biomarker status (see Biomarkers Annotation), I explore these scenarios:\n\nClustering of all 3273 patients and annotation according to PAM50 subtypes (consensus histopathology labels​) provided in the metadata\nClustering of patients with complete annotations for all 5 biomarkers (1373 patients)\nClustering of patients separately for each biomarker (excluding NA)\n\nFor each clustering scenario, I considered the top 3000 genes that exhibit the highest patient-to-patient variation in the dataset (i.e, those genes that are highly expressed in some patients, and lowly expressed in others)."
  },
  {
    "objectID": "r2_clustering.html#results",
    "href": "r2_clustering.html#results",
    "title": "Identification of breast cancer subtypes",
    "section": "Results",
    "text": "Results\nOverall, the analysis suggests that patients stratify according to the 5 biomarkers, in particular according to ER and PgR status.\nLoading data\n\ngexp &lt;- read_csv(\n  'data/gene_expression_profile.csv.gz',\n  col_types = cols()\n)\n\nmeta &lt;- read_csv('data/metadata.csv', col_types = cols()) |&gt;\n  rename(sampleID = values, sampleName = ind) |&gt;\n  filter(sampleID %in% names(gexp)) |&gt;\n  mutate(\n    er_status = factor(er_status, levels = c(0, 1), labels = c(\"ER-\", \"ER+\")),\n    pgr_status = factor(pgr_status, levels = c(0, 1), labels = c(\"PgR-\", \"PgR+\")),\n    her2_status = factor(her2_status, levels = c(0, 1), labels = c(\"HER2-\", \"HER2+\")),\n    ki67_status = factor(ki67_status, levels = c(0, 1), labels = c(\"Ki67-\", \"Ki67+\")),\n    overall_survival_event = factor(overall_survival_event, levels = c(0, 1), labels = c(\"no survival\", \"survival\")),\n    endocrine_treated = factor(endocrine_treated, levels = c(0, 1), labels = c(\"no treated\", \"treated\")),\n    chemo_treated = factor(chemo_treated, levels = c(0, 1), labels = c(\"no treated\", \"treated\")),\n    lymph_node_group = factor(lymph_node_group),\n    lymph_node_status = factor(lymph_node_status),\n    pam50_subtype = factor(pam50_subtype),\n    nhg = factor(nhg)\n  )\n\n\nmd &lt;- meta |&gt; \n  column_to_rownames(var = 'sampleID')\n\nmx &lt;- gexp |&gt; \n  select(genes, rownames(md)) |&gt;\n  column_to_rownames(var = 'genes')\n\nBiomarkers Annotation\nPercentage of patients with a given annotation is reported for each biomarker.\n\nmeta_long &lt;- meta |&gt;\n  select(er_status, pgr_status, her2_status, ki67_status, nhg) |&gt;\n  pivot_longer(cols = everything(), names_to = \"biomarker\", values_to = \"status\")\n\ndf_counts &lt;- meta_long |&gt;\n  group_by(biomarker, status) |&gt;\n  summarise(n = n(), .groups = \"drop\") |&gt;\n  group_by(biomarker) |&gt;\n  mutate(perc = n / sum(n))\n\nggplot(df_counts, aes(x = biomarker, y = perc, fill = status)) +\n  geom_bar(stat = \"identity\") +\n  geom_text(\n    aes(label = scales::percent(perc, accuracy = 1)),\n    position = position_stack(vjust = 0.5)\n  ) +\n  labs(x = \"\", y = \"\") +\n  scale_y_continuous(labels = percent_format(accuracy = 1)) +\n  guides(fill = guide_legend(title = NULL)) +\n  theme_minimal() +\n  theme(\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank()\n  )\n\n\n\n\n\n\n\nFunctions\nFunctions used to build the pipeline.\n\ntop_genes &lt;- function(mat, n_top = 500){\n  # use smallest between n_top and number of genes\n  n_top &lt;- min(n_top, nrow(mat))\n  # order by decreasing gene variance and slice\n  rv &lt;- matrixStats::rowVars(as.matrix(mat))\n  select_n &lt;- order(rv, decreasing = TRUE)[seq_len(n_top)]\n  mat &lt;- mat[select_n, ]\n  return(mat)\n}\n\nget_pc &lt;- function(mx, md){\n  pc &lt;- PCAtools::pca(mx, metadata = md, center = TRUE, scale = FALSE, removeVar = 0.1)\n  return(pc)\n}\n\nbuild_graph &lt;- function(pc, npc = 25, k = 20){\n  ## pc space\n  pcm &lt;- pc$rotated[, 1:npc]\n\n  # find k-nearest neighbors\n  knn_result &lt;- RANN::nn2(pcm, k = k)\n  knn_idx &lt;- knn_result$nn.idx\n  \n  # store sparse matrix triplets (i, j, value)\n  i_indices &lt;- c()\n  j_indices &lt;- c()\n  values &lt;- c()\n\n  npat &lt;- nrow(pcm)\n  # adj &lt;- matrix(0, npat, npat)\n\n  for (i in 1:npat){\n    for (j in knn_idx[i, ]){\n      if (i != j){ ## avoid self-loop\n        neighbors_i &lt;- knn_idx[i,]\n        neighbors_j &lt;- knn_idx[j,]\n        jaccard_sim &lt;- length(intersect(neighbors_i, neighbors_j)) / \n                       length(union(neighbors_i, neighbors_j)) ## union takes unique values\n\n        # Store indices and values for sparse matrix\n        i_indices &lt;- c(i_indices, i)\n        j_indices &lt;- c(j_indices, j)\n        values &lt;- c(values, jaccard_sim)\n        \n        # dense matrix \n        # adjt[i, j] &lt;- jaccard_sim\n      }\n    }\n  }\n\n  # Create sparse matrix using triplet format\n  adj &lt;- sparseMatrix(i = i_indices, j = j_indices, x = values, dims = c(npat, npat))\n\n  # build graph\n  g &lt;- graph_from_adjacency_matrix(adj,\n    mode = \"max\", ## preserve the strongest connections, same of adj &lt;- pmax(adj, t(adj))\n    weighted = TRUE\n  )\n  return(g)\n}\n\nfind_clusters &lt;- function(g, mx, resolution = 1){\n  # Louvain algorithm for community detection\n  louvain_communities &lt;- cluster_louvain(g, resolution = resolution)\n\n  # cluster assignment\n  clusters &lt;- membership(louvain_communities)\n\n  return(clusters)\n}\n\n## umap wrapper\numap &lt;- function(mx, ...){\n  defaults &lt;- list(\n    n_components = 2,\n    n_neighbors = 20,     ## as perplexity in t-SNE\n    min_dist = 0.1,       ## how tightly points cluster together\n    metric = \"euclidean\",\n    spread = 1,           ## global structure preservation\n    n_threads = 10\n  )\n  user_args &lt;- modifyList(defaults, list(...))\n  purrr::exec(uwot::umap, X = t(mx), !!!user_args)\n}\n\n## tsne wrapper\ntsne &lt;- function(mx, ...){\n  defaults &lt;- list(\n    dims = 2,\n    perplexity = 20,\n    num_threads = 10\n  )\n  user_args &lt;- modifyList(defaults, list(...))\n  purrr::exec(Rtsne::Rtsne, X = t(mx), !!!user_args)\n}\n\njoin_results &lt;- function(tib, pc, clusters){\n  if(is.list(tib)){ ## tsne returns a list ..\n    restib &lt;- tibble(\n      sample = rownames(pc$rotated),\n      cluster = as.factor(clusters),\n      tsne1 = tib$Y[, 1],\n      tsne2 = tib$Y[, 2]) |&gt;\n      left_join(meta, by = c('sample' = 'sampleID'))\n  }else{ ## .. umap a dataframe\n    restib &lt;- tibble(\n      sample = rownames(pc$rotated),\n      cluster = as.factor(clusters),\n      umap1 = tib[, 1],\n      umap2 = tib[, 2]) |&gt;\n      left_join(meta, by = c('sample' = 'sampleID'))\n  }\n  return(restib)\n}\n\nplot_clusters &lt;- function(tib, cluster = 'cluster', animate = FALSE){\n  dim1 &lt;- colnames(tib)[3]\n  dim2 &lt;- colnames(tib)[4]\n  \n  p &lt;- ggplot(tib, aes(x = !!sym(dim1), y = !!sym(dim2), color = !!sym(cluster))) +\n    geom_point(alpha = 0.7, size = 2) +\n    labs(title = str_replace(cluster, '_', ' '), x = dim1, y = dim2) +\n    theme_minimal()\n\n  if(!animate & cluster == 'cluster'){\n    # Calculate cluster centroids for label positioning\n    cluster_centers &lt;- tib |&gt;\n      group_by(!!sym(cluster)) |&gt;\n      summarise(\n        x_center = mean(!!sym(dim1), na.rm = TRUE),\n        y_center = mean(!!sym(dim2), na.rm = TRUE),\n        .groups = 'drop'\n      )\n    \n    p &lt;- p +\n      geom_text_repel(\n        data = cluster_centers,\n        aes(x = x_center, y = y_center, label = !!sym(cluster)),\n        color = \"black\",\n        size = 8,\n        fontface = \"bold\",\n        vjust = 0.5,\n        hjust = 0.5\n      )\n  }\n  return(p)\n}\n\nformatter &lt;- function(tib, cols_to_format = \"all\", digits = 3){\n  selector &lt;- if(length(cols_to_format) == 1 && cols_to_format == \"all\"){\n    where(is.numeric)\n  } else {\n    all_of(cols_to_format)\n  }\n\n  tib |&gt; \n    mutate(across({{ selector }},\n           ~format(., scientific = TRUE, digits = digits)))\n}\n\ndatatable &lt;- function(tib, row2display = 10) {\n  if(nrow(tib) &gt; 0){\n    DT::datatable(tib,\n      rownames   = FALSE,\n      extensions = \"Buttons\",\n      options    = list(\n        dom = \"Bfrtip\",\n        scrollX = TRUE,\n        pageLength = row2display,\n        buttons = list(\n          list(\n            extend  = \"collection\",\n            buttons = c(\"csv\", \"excel\"),\n            text    = \"Download\"\n          )\n        )\n      )\n    )\n  }else{\n    print(\"No results\")\n  }\n}\n\nA. Clustering all the patients\n\nmxtop &lt;- top_genes(mx, n_top = 3000)\npc &lt;- get_pc(mxtop, md)\ng &lt;- build_graph(pc, npc = 25, k = 20)\ncls &lt;- find_clusters(g, mxtop, resolution = 1)\n\nt-SNE\n\ntsneres &lt;- tsne(mxtop, perplexity = 20)\ntsnetib &lt;- join_results(tsneres, pc, cls)\n\nvars &lt;- c('cluster', 'pam50_subtype')\nplist &lt;- map(vars, ~plot_clusters(tsnetib, .x))\nwrap_plots(plist, ncol = 2)\n\n\n\n\n\n\n\nUMAP\n\numapres &lt;- umap(mxtop, n_neighbors = 20, spread = 1)\numaptib &lt;- join_results(umapres, pc, cls)\n\nvars &lt;- c('cluster', 'pam50_subtype')\nplist &lt;- map(vars, ~plot_clusters(umaptib, .x))\nwrap_plots(plist, ncol = 2)\n\n\n\n\n\n\n\nPatient cluster assignment\nThe table below shows the obtained cluster assignment for each patient.\n\ntsnetib |&gt; \n  left_join(umaptib, by = 'sample', suffix=c('_tsne', '_umap')) |&gt;\n  select(sample, sampleName_tsne, cluster_tsne, \n  tsne1, tsne2, umap1, umap2, \n  tumor_size_tsne, lymph_node_group_tsne, \n  lymph_node_status_tsne, er_status_tsne, \n  pgr_status_tsne, her2_status_tsne,           \n  ki67_status_tsne, nhg_tsne, \n  overall_survival_days_tsne, overall_survival_event_tsne,\n  endocrine_treated_tsne, chemo_treated_tsne) |&gt; \n  rename_with(~ str_remove(.x, \"_tsne$\")) |&gt;\n  formatter(cols_to_format = c(\"tsne1\", \"tsne2\", \"umap1\", \"umap2\")) |&gt;\n  datatable()\n\n\n\n\n\nB. Clustering of patients with complete annotations for all 5 biomarkers\n\n## reduce dataset to complete cases \nmd_complete &lt;- meta |&gt;\n  filter(!is.na(er_status)   & !is.na(pgr_status) & \n         !is.na(her2_status) & !is.na(ki67_status) &\n         !is.na(nhg)) |&gt;\n  column_to_rownames(var = 'sampleID')       \n\nmx_complete &lt;- gexp |&gt; \n    select(genes, rownames(md_complete)) |&gt;\n    column_to_rownames(var = 'genes')\n\n\n## run pipeline\nmxtop_complete &lt;- top_genes(mx_complete, n_top = 3000)\npc_complete &lt;- get_pc(mxtop_complete, md_complete)\ng_complete &lt;- build_graph(pc_complete, npc = 25, k = 20)\ncls_complete &lt;- find_clusters(g_complete, mxtop_complete, resolution = 1)\n\nt-SNE\n\nvars &lt;- c('cluster', 'er_status', 'pgr_status', 'her2_status', 'ki67_status', 'nhg')\n\n## tsne\ntsneres_complete &lt;- tsne(mxtop_complete, perplexity = 20)\ntsnetib_complete &lt;- join_results(tsneres_complete, pc_complete, cls_complete)\n\nplist &lt;- map(vars, ~plot_clusters(tsnetib_complete, .x))\nwrap_plots(plist, ncol = 2)\n\n\n\n\n\n\n\nUMAP\n\numapres_complete &lt;- umap(mxtop_complete, n_neighbors = 20, spread = 1)\numaptib_complete &lt;- join_results(umapres_complete, pc_complete, cls_complete)\n\nplist &lt;- map(vars, ~plot_clusters(umaptib_complete, .x))\nwrap_plots(plist, ncol = 2)\n\n\n\n\n\n\n\nC. Clustering of patients separately for each biomarker\n\nbiomarkers &lt;- c('er_status', 'pgr_status', 'her2_status', 'ki67_status', 'nhg')\n\ntsnetib_bm &lt;- list()\numaptib_bm &lt;- list()\n\nptsne &lt;- list()\npumap &lt;- list()\n\nfor(biomarker in biomarkers){\n  ## remove not annotated patients\n  md_bm &lt;- meta |&gt;\n    filter(!is.na(!!sym(biomarker))) |&gt;\n    column_to_rownames(var = 'sampleID')\n\n  mx_bm &lt;- gexp |&gt; \n    select(genes, rownames(md_bm)) |&gt;\n    column_to_rownames(var = 'genes')\n\n  ## clustering\n  mxtop_bm &lt;- top_genes(mx_bm, n_top = 3000)\n  pc_bm &lt;- get_pc(mxtop_bm, md_bm)\n  g_bm &lt;- build_graph(pc_bm, npc = 25, k = 20)\n  cls_bm &lt;- find_clusters(g_bm, mxtop_bm, resolution = 1)\n\n  ## save results\n  tsneres_bm &lt;- tsne(mxtop_bm, perplexity = 20)\n  tsnetib_bm[[biomarker]] &lt;- join_results(tsneres_bm, pc_bm, cls_bm)\n\n  umapres_bm &lt;- umap(mxtop_bm,  n_neighbors = 20)\n  umaptib_bm[[biomarker]] &lt;- join_results(umapres_bm, pc_bm, cls_bm)\n\n  vars &lt;- c('cluster', biomarker)\n  ptsne[[biomarker]] &lt;- map(vars, ~plot_clusters(tsnetib_bm[[biomarker]], .x))\n  pumap[[biomarker]] &lt;- map(vars, ~plot_clusters(umaptib_bm[[biomarker]], .x))\n}\n\nt-SNE\n\npwrap &lt;- map(ptsne, ~.x[[1]] + .x[[2]])\nwrap_plots(pwrap, ncol = 1)\n\n\n\n\n\n\n\nUMAP\n\npwrap &lt;- map(pumap, ~.x[[1]] + .x[[2]])\nwrap_plots(pwrap, ncol = 1)\n\n\n\n\n\n\n\nClustering at different resolutions\nClusters detected at each resolutions are marked in different colors. Patients in the community colored in red tend to cluster together at different resolutions, suggesting that patients within this community are strongly connected (similar expression profiles).\n\n# loop for resolutions\nresolutions &lt;- c(0.1, 0.3, 0.6, 1, 1.5)\n\ntsne_tune &lt;- map_dfr(resolutions, function(resolution){\n  cls &lt;- find_clusters(g, mxtop, resolution = resolution) \n  tsne &lt;- tsne(mxtop, dims = 2, perplexity = 20)\n  tibble(\n    sample = colnames(mxtop),\n    cluster = as.factor(cls),\n    tsne1 = tsne$Y[, 1],\n    tsne2 = tsne$Y[, 2],\n    resolution = resolution,\n    ncl = length(unique(cls)) ## number of clusters at a given resolution\n  ) |&gt;\n  left_join(meta, by = c('sample' = 'sampleID'))\n})\n\n# {unique(tsne_tune$ncl[tsne_tune$resolution == closest_state])}\nncl_lookup &lt;- tsne_tune |&gt; distinct(resolution, ncl) |&gt; deframe()\n\nplot &lt;- plot_clusters(tsne_tune, cluster = 'cluster', animate = TRUE) +\n  # theme(legend.position=\"none\") +\n  labs(subtitle = \"Resolution: {closest_state} | Clusters: {ncl_lookup[as.character(closest_state)]}\") +\n  transition_states(resolution, transition_length = 5, state_length = 3) +\n  ease_aes(\"linear\")\n\nanimate(\n  plot,\n  width = 8,\n  height = 6,\n  res = 100,\n  nframes = 300,\n  fps = 30,\n  device = \"ragg_png\",\n  renderer = gifski_renderer()\n)\n\n\n\n\n\n\n\nWhen specifically coloring patients based on ER status, we observe that the expression profiles of ER- patients cluster well. Furthermore, it is worth noting that the status of some patients within this cluster is unknown (gray patients). These might be considered as ER- patients since they cluster strongly with patients annotated as ER-.\n\nplot &lt;- plot_clusters(tsne_tune, cluster = 'er_status', animate = TRUE) +\n  labs(subtitle = \"Resolution: {closest_state} | Clusters: {ncl_lookup[as.character(closest_state)]}\") +\n  transition_states(resolution, transition_length = 5, state_length = 3) +\n  ease_aes(\"linear\")\n\nanimate(\n  plot,\n  width = 8,\n  height = 6,\n  res = 100,\n  nframes = 300,\n  fps = 30,\n  device = \"ragg_png\",\n  renderer = gifski_renderer()\n)"
  },
  {
    "objectID": "r2_clustering.html#conclusions",
    "href": "r2_clustering.html#conclusions",
    "title": "Identification of breast cancer subtypes",
    "section": "Conclusions",
    "text": "Conclusions\nI identified breast cancer subtypes based on gene expression data via a graph-based approach. Two main distinct clusters of patients are detected. The smaller cluster is enriched for ER- patients and likely represent the most aggressive expression profile (basal PAM50 subtype, e.g. G3, PgR-, ER-, HER-)."
  },
  {
    "objectID": "r2_clustering.html#next-step",
    "href": "r2_clustering.html#next-step",
    "title": "Identification of breast cancer subtypes",
    "section": "Next step",
    "text": "Next step\nCluster assignment can be used as features in a supervised learning approach to predict biomarker status (such as random forest, support vector machine, label propagation). Furthermore, we can use LLMs to further validate biological insights using AI-powered tools tailored for bioinformatics resources such as ExpasyGPT."
  },
  {
    "objectID": "r0_getdata.html",
    "href": "r0_getdata.html",
    "title": "Downloading GEO data",
    "section": "",
    "text": "In this report, I download the 3409 breast cancer bulk RNA-seq samples and the corresponding clinical annotations, associated with the study: Clinical Value of RNA Sequencing-Based Classifiers for Prediction of the Five Conventional Breast Cancer Biomarkers: A Report From the Population-Based Multicenter Sweden Cancerome Analysis Network—Breast Initiative (GSE96058).\n\n\nif(!dir.exists(here::here('data')))\n  dir.create(here::here('data'))\n\n\n## get geo obj\ngeo &lt;- getGEO(GEO = \"GSE96058\", GSEMatrix = FALSE)\n\n## fetch metadata\nmeta &lt;- purrr::map(geo@gsms, ~.x@header$characteristics_ch1) |&gt;\n  stack() |&gt;\n  tidyr::separate(values, into = c(\"feature\", \"value\"), sep= \": \") |&gt;\n  tidyr::pivot_wider(names_from= feature, values_from = value) |&gt;\n  janitor::clean_names()\n\n## map samples\nsample &lt;- purrr::map(geo@gsms, ~.x@header$title) |&gt;\n  stack() |&gt;\n  as_tibble() |&gt;\n  mutate(ind = as.character(ind))\n\n## store metadata\nmeta &lt;- left_join(sample, meta, by = 'ind') |&gt;\n  write_csv(here::here(\"data/metadata.csv\"))\n\n\n\nsuccess &lt;- FALSE\nattempt &lt;- 1\nwhile (!success && attempt &lt;= 5) {\n  tryCatch({\n    getGEOSuppFiles(\"GSE96058\", makeDirectory = FALSE,\n                    baseDir = here::here('data'),\n                    fetch_files = TRUE, filter_regex = 'gene_expression')\n    success &lt;- TRUE\n    message(\"Download successful on attempt \", attempt)\n  }, error = function(e) {\n    message(\"Download failed on attempt \", attempt, \": \", e$message)\n    attempt &lt;&lt;- attempt + 1\n    Sys.sleep(5) # wait before retrying\n  })\n}\nif (!success)\n  stop(sprintf(\"Download failed after %s attempts\", attempt))"
  },
  {
    "objectID": "r0_getdata.html#aims",
    "href": "r0_getdata.html#aims",
    "title": "Downloading GEO data",
    "section": "",
    "text": "In this report, I download the 3409 breast cancer bulk RNA-seq samples and the corresponding clinical annotations, associated with the study: Clinical Value of RNA Sequencing-Based Classifiers for Prediction of the Five Conventional Breast Cancer Biomarkers: A Report From the Population-Based Multicenter Sweden Cancerome Analysis Network—Breast Initiative (GSE96058).\n\n\nif(!dir.exists(here::here('data')))\n  dir.create(here::here('data'))\n\n\n## get geo obj\ngeo &lt;- getGEO(GEO = \"GSE96058\", GSEMatrix = FALSE)\n\n## fetch metadata\nmeta &lt;- purrr::map(geo@gsms, ~.x@header$characteristics_ch1) |&gt;\n  stack() |&gt;\n  tidyr::separate(values, into = c(\"feature\", \"value\"), sep= \": \") |&gt;\n  tidyr::pivot_wider(names_from= feature, values_from = value) |&gt;\n  janitor::clean_names()\n\n## map samples\nsample &lt;- purrr::map(geo@gsms, ~.x@header$title) |&gt;\n  stack() |&gt;\n  as_tibble() |&gt;\n  mutate(ind = as.character(ind))\n\n## store metadata\nmeta &lt;- left_join(sample, meta, by = 'ind') |&gt;\n  write_csv(here::here(\"data/metadata.csv\"))\n\n\n\nsuccess &lt;- FALSE\nattempt &lt;- 1\nwhile (!success && attempt &lt;= 5) {\n  tryCatch({\n    getGEOSuppFiles(\"GSE96058\", makeDirectory = FALSE,\n                    baseDir = here::here('data'),\n                    fetch_files = TRUE, filter_regex = 'gene_expression')\n    success &lt;- TRUE\n    message(\"Download successful on attempt \", attempt)\n  }, error = function(e) {\n    message(\"Download failed on attempt \", attempt, \": \", e$message)\n    attempt &lt;&lt;- attempt + 1\n    Sys.sleep(5) # wait before retrying\n  })\n}\nif (!success)\n  stop(sprintf(\"Download failed after %s attempts\", attempt))"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "This page contains the data analysis reports for the identification of breast cancer subtypes via a graph-based approach from a public bulk RNA-Seq patient cohort.\n\nGetting data\nExploratory data analysis and preprocessing\nClustering analysis"
  },
  {
    "objectID": "r1_eda.html",
    "href": "r1_eda.html",
    "title": "Exploratory data analysis: validation of technical replicates",
    "section": "",
    "text": "The GSE96058 patient cohort contains 3273 samples of which 136 have technical replicates. Some of these replicates were sequenced on a different sequencer (HiSeq2000 and NextSeq500). In this report, I analyze the gene expression profiles of these technical replicates to assess their similarity. This serves as a technical validation before averaging their gene expression values."
  },
  {
    "objectID": "r1_eda.html#aims",
    "href": "r1_eda.html#aims",
    "title": "Exploratory data analysis: validation of technical replicates",
    "section": "",
    "text": "The GSE96058 patient cohort contains 3273 samples of which 136 have technical replicates. Some of these replicates were sequenced on a different sequencer (HiSeq2000 and NextSeq500). In this report, I analyze the gene expression profiles of these technical replicates to assess their similarity. This serves as a technical validation before averaging their gene expression values."
  },
  {
    "objectID": "r1_eda.html#validation-of-technical-replicates",
    "href": "r1_eda.html#validation-of-technical-replicates",
    "title": "Exploratory data analysis: validation of technical replicates",
    "section": "Validation of technical replicates",
    "text": "Validation of technical replicates\n\n\n\n\n\n\nNote\n\n\n\nThe authors provided only transformed gene expression data, which I then used for downstream analysis.\n\n\nLoading data\n\ngexp &lt;- read_csv(\n  'data/GSE96058_gene_expression_3273_samples_and_136_replicates_transformed.csv.gz', \n  col_types = cols()\n) |&gt; rename(genes = `...1`)\n\nmeta &lt;- read_csv('data/metadata.csv', col_types = cols()) |&gt;\n  rename(sampleID = values, sampleName = ind)\n\n\nrep &lt;- gexp |&gt; select(contains('repl')) |&gt; colnames() |&gt; str_remove('repl')\n\nmxrep &lt;- gexp |&gt; \n  select(genes, all_of(rep) | contains('repl')) |&gt; \n  column_to_rownames(var = 'genes') \n\nmdrep &lt;- meta |&gt; \n  filter(sampleID %in% colnames(mxrep)) |&gt;\n  select(sampleID, instrument_model, age_at_diagnosis, \n         tumor_size, lymph_node_group, lymph_node_status, \n         her2_status, ki67_status, pgr_status, nhg, \n         endocrine_treated, chemo_treated) |&gt; \n  column_to_rownames(var = 'sampleID')\n\nPCA\nI apply a Principal Component Analysis (PCA) on the gene expression profiles of technical replicates (marked with the same color) to assess similarity in gene expression. As expected, technical replicates cluster together.\n\npc &lt;- PCAtools::pca(mxrep, metadata = mdrep, center = TRUE, scale = FALSE, removeVar = 0.1)\n\nstopifnot(rownames(mdrep) %in% rownames(pc$rotated))\n\nplot_pca &lt;- function(pc, pcx ='PC1', pcy = 'PC2'){\n  pc_data &lt;- cbind(pc$rotated[, c(pcx, pcy)], mdrep) |&gt;\n    rownames_to_column(var = 'sample')|&gt;\n    mutate(strip_rep = str_replace(sample, 'repl', ''))\n\n  pc_val &lt;- round(pc$variance[c(pcx, pcy)], 2) |&gt; unname()\n\n  ggplot(pc_data, aes(x = !!sym(pcx), y = !!sym(pcy), color = strip_rep, shape = instrument_model)) +\n    geom_point(size = 3) + \n    labs(title = \"\",\n         x = paste0(\"PC1 (\", pc_val[1], \"% variance)\"),\n         y = paste0(\"PC2 (\", pc_val[2], \"% variance)\"),\n         shape = \"Platform\",) +\n    geom_text_repel(data = pc_data, \n                    aes(label = sample), \n                    min.segment.length = 5, max.overlaps = Inf) +\n    theme_bw() +\n    theme(plot.title = element_text(hjust = 0.5)) +\n    guides(color = \"none\")\n}\n\nplot_pca(pc, pcx ='PC1', pcy = 'PC2')\n\n\n\n\n\n\n\nSample correlations\nFor a quantitative overview, I compute the Spearman’s rank correlation for each pair. As expected, technical replicates are strongly correlated (coefficient higher than 0.9) and their gene expression can be safely averaged for downstream analyses.\n\nmxrep_paired &lt;- mxrep[, str_sort(colnames(mxrep), numeric = TRUE)]\n\ntib &lt;- tibble(\n  comparison = character(),\n  correlation = numeric(),\n  p_value = numeric(),\n  informative = logical(),\n  significant = logical()\n)\n\nfor(i in seq(1, ncol(mxrep_paired)-1, by = 2)){\n  corr &lt;- cor.test(mxrep_paired[, i], \n                   mxrep_paired[, i+1], \n                   method = 'spearman',\n                   exact = FALSE\n                  )\n\n  tmp &lt;- tibble(\n    comparison = paste(colnames(mxrep_paired)[i:(i+1)], collapse=' vs '),\n    correlation = round(corr$estimate, 2),\n    p_value = corr$p.value,\n    informative =  round(corr$estimate, 2) &gt;= 0.90,\n    significant = corr$p.value &lt; 0.05\n  )\n\n  tib &lt;- rbind(tib, tmp)\n}\n\ndatatable &lt;- function(tib, row2display = 10) {\n  if(nrow(tib) &gt; 0){\n    DT::datatable(tib,\n      rownames   = FALSE,\n      options    = list(\n        dom = \"Bfrtip\",\n        scrollX = TRUE,\n        pageLength = row2display\n      )\n    )\n  }else{\n    print(\"No results\")\n  }\n}\ntib |&gt; datatable()\n\n\n\n\n\nAs an example, below I show the scatter plots of the first 12 pairs.\n\nscatter_plot &lt;- function(data, sample, replicate) {\n  ggplot(data, aes(x = !!sym(sample), y = !!sym(replicate))) +\n    geom_point(colour = \"#56B4E9\", alpha = 0.8, size = 1) +\n    geom_smooth(method = \"lm\", color = \"#D55E00\", formula = y ~ x, se = TRUE) +\n    labs(\n      title = paste(sample, \"vs\", replicate),\n      subtitle = paste(\"r =\", round(cor(data[[sample]], data[[replicate]], method = \"spearman\"), 3))\n    ) +\n    theme_bw() +\n    theme(\n      plot.title = element_text(size = 10),\n      plot.subtitle = element_text(size = 8)\n    )\n}\n\nget_pair &lt;- function(tib, npairs=10){\n  pairs &lt;- str_split(tib$comparison, \" vs \", simplify = TRUE)[1:npairs,]\n  sample &lt;- pairs[, 1]\n  replicate &lt;- pairs[, 2]\n  return(list(sample = sample, replicate = replicate))\n}\n\nsp &lt;- get_pair(tib, npairs = 12)\nplist &lt;- map2(sp$sample, sp$replicate, ~scatter_plot(mxrep, .x, .y))\nwrap_plots(plist, ncol = 4)"
  },
  {
    "objectID": "r1_eda.html#averaging-of-gene-expression-of-technical-replicates",
    "href": "r1_eda.html#averaging-of-gene-expression-of-technical-replicates",
    "title": "Exploratory data analysis: validation of technical replicates",
    "section": "Averaging of gene expression of technical replicates",
    "text": "Averaging of gene expression of technical replicates\n\nmxrep_averaged &lt;- c()\n\nfor(i in seq(1, ncol(mxrep_paired)-1, by = 2)){\n  mxrep_averaged &lt;- cbind(mxrep_averaged, rowMeans(mxrep_paired[,i:(i+1)]))\n  # cat(colnames(mxrep_paired)[i], colnames(mxrep_paired)[i+1], 'averaged\\n')\n}\n\nnorep &lt;- str_subset(colnames(mxrep_paired), 'repl', negate=TRUE)\ncolnames(mxrep_averaged) &lt;- norep\n\ngexp_rep &lt;- mxrep_averaged |&gt; \n  as.data.frame() |&gt; \n  rownames_to_column(var = 'genes') |&gt; \n  as_tibble()\n\nfout &lt;- 'data/gene_expression_profile.csv.gz'\nif(!file.exists(fout)){\n  gexp |&gt; \n    select(-all_of(colnames(gexp_rep)[-1])) |&gt; \n    left_join(gexp_rep, by = 'genes') |&gt; \n    select(-ends_with(\"repl\")) |&gt;\n    {\\(s)  ## lambda function ..\n      select(s, genes, all_of(str_sort(names(select(s, starts_with(\"F\"))), numeric = TRUE)))\n    }() |&gt;\n    ## %&gt;% select(., all_of(str_sort(colnames(select(., starts_with('F'))), numeric = TRUE)))\n    write_csv(fout) ## automatically compress by readr\n}"
  }
]